<html>
  <head>
    <title>container + WASI on browser</title>
    <link href="https://esm.archive.org/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@4.17.0/css/xterm.css">
  </head>
  <body>
    <h1 style="text-align:center">
      docker containers, compiled into WASM, using JS in a browser
    </h1>
    examples can take a minute or so to load since even small docker images expand a bit, examples:
    <ul>
      <li>7MB 'alpine' docker linux image => 96MB .wasm file</li>
      <li>117MB 'debian:bookworm' linux image => 189MB .wasm file</li>
      <li>52MB 'python:3-alpine' image => 138MB .wasm file</li>
      <li>See more demo sizes <a href="./wasm/">here</a></li>
    </ul>

    <i>Presently defaulting to networking via browser `fetch()` which requires CORS open responses for requested urls.</i>
    <p>
      For a networking "out" example, try the `alpine` demo and:
    </p>
    <code>
      wget -qO- https://esm.archive.org/jquery
    </code>

    <div id="terminal"></div>
    <script src="https://cdn.jsdelivr.net/npm/xterm@4.17.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-pty@0.9.4/index.js"></script>
    <script src="./stack.js"></script>
    <script src="./ws-delegate.js"></script>
    <script>
      let WASM = 'alpine.wasm'
      for (const args of location.search.substring(1).split('&')) {
          const kv = args.split('=');
          if (decodeURIComponent(kv[0]) == 'wasm')
            WASM = kv[1]
      }
      fetch('./wasm/').then((e) => e.text()).then((txt) => {
        let htm = `<hr><b>Pick a wasm image (defaults to ${WASM}):</b>`
        for (const wasm of [...txt.matchAll(/([^/]+\.wasm)"/gi)].map((e) => e[1])
          .filter((e) => e !== 'c2w-net-proxy.wasm')) {
          htm += `<li><a href="${location.origin}?wasm=${wasm}">${wasm}</a></li>`
        }
        const el = document.createElement('ul')
        el.innerHTML = htm
        document.getElementById('terminal').before(el)
      })

      const xterm = new Terminal();
      xterm.open(document.getElementById("terminal"));

      const { master, slave } = openpty();

      termios = slave.ioctl("TCGETS");
      termios.iflag &= ~(/*IGNBRK | BRKINT | PARMRK |*/ ISTRIP | INLCR | IGNCR | ICRNL | IXON);
      termios.oflag &= ~(OPOST);
      termios.lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
      //termios.cflag &= ~(CSIZE | PARENB);
      //termios.cflag |= CS8;
      slave.ioctl("TCSETS", new Termios(termios.iflag, termios.oflag, termios.cflag, termios.lflag, termios.cc));
      xterm.loadAddon(master);
      const worker = new Worker("./worker.js"+location.search);

      var nwStack;
      var netParam = getNetParam();
      var workerImage = `${location.origin}/wasm/${WASM}`
      if (netParam) {
          if (netParam.mode == 'delegate') {
              nwStack = delegate(worker, workerImage, netParam.param);
          } else if (netParam.mode == 'browser') {
              nwStack = newStack(worker, workerImage, new Worker("./stack-worker.js"+location.search), location.origin + "/wasm/c2w-net-proxy.wasm");
          }
      }
      if (!nwStack) {
          worker.postMessage({type: "init", imagename: workerImage});
      }
      new TtyServer(slave).start(worker, nwStack);

      function getNetParam() {
          var vars = location.search.substring(1).split('&');
          for (var i = 0; i < vars.length; i++) {
              var kv = vars[i].split('=');
              if (decodeURIComponent(kv[0]) == 'net') {
                  return {
                      mode: kv[1],
                      param: kv[2],
                  };
              }
          }
          return { mode: "browser", param: undefined }
      }
    </script>
  </body>
</html>
